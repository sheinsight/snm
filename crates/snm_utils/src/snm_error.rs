use colored::*;
use std::{env, path::PathBuf, process::exit};
use thiserror::Error;

use crate::fmtln;

#[derive(Error, Debug)]
pub enum SnmError {
    #[error("Build config error: {0}")]
    BuildConfigError(#[from] config::ConfigError),

    #[error("IO error: {0}")]
    IOError(#[from] std::io::Error),

    #[error("Dialoguer error: {0}")]
    DialoguerError(#[from] dialoguer::Error),

    #[error("Network error: {0}")]
    NetworkError(#[from] reqwest::Error),

    #[error("Get var error :{0}")]
    VarError(#[from] std::env::VarError),

    #[error("Zip error: {0}")]
    ZipError(#[from] zip::result::ZipError),

    #[error("Deserialize error: {0}")]
    DeserializeError(#[from] serde_json::Error),

    #[error("Http status code not ok")]
    HttpStatusCodeUnOk,

    #[error("Get home dir error")]
    GetHomeDirError,

    #[error("Get workspace dir error")]
    GetWorkspaceError,

    #[error("No default node binary")]
    NoDefaultNodeBinary,

    #[error("File already exists {file_path}")]
    FileAlreadyExists { file_path: PathBuf },

    #[error("Exceeded maximum retry attempts: {0}")]
    ExceededMaxRetries(String),

    #[error("{stderr}")]
    SNMBinaryProxyFail { stderr: String },

    #[error("Shasum error: {file_path} , expect: {expect} , actual: {actual}")]
    ShasumError {
        file_path: String,
        expect: String,
        actual: String,
    },

    #[error("Unsupported node version: {version}")]
    UnsupportedNodeVersionError {
        version: String,
        node_white_list: Vec<String>,
    },

    #[error("Not found command: {bin_name}")]
    NotFoundCommandError { bin_name: String },

    #[error("Not found package.json file")]
    NotFoundPackageJsonFileError {},

    #[error("Not found package manager config")]
    NotFondPackageManagerConfigError {},

    #[error("{raw_package_manager}")]
    ParsePackageManagerError { raw_package_manager: String },

    #[error("Package manager version not match, expected: {expect}, actual: {actual}")]
    NotMatchPackageManagerError {
        raw_command: String,
        expect: String,
        actual: String,
    },

    #[error("Unsupported package manager: {name}")]
    UnsupportedPackageManagerError {
        raw: String,
        name: String,
        supported: Vec<String>,
    },
}

pub fn create_error_message(message: String, descriptions: Vec<String>) -> String {
    let description = descriptions
        .iter()
        .map(|value| format!("{:<4}{}", "", value))
        .collect::<Vec<String>>()
        .join("\r\n".repeat(1).as_str());

    format!(
        r##"
{:<3}{}.

{:<3}{}

{}
"##,
        "üëπ", message, "üìã", "Explain", description
    )
}

pub fn hack(error: SnmError) {
    let white_list = env::var("SNM_NODE_WHITE_LIST").unwrap();

    match error {
        SnmError::NoDefaultNodeBinary => {
            let message = format!(
                r##"
ÈîôËØØ: Ê≤°ÊúâÊâæÂà∞ÂèØÊâßË°åÁöÑÈªòËÆ§ Node

ÊñπÊ°àÔºö
     Â¶ÇÊûú‰Ω†‰∏çÊÉ≥Áúã‰∏ãÈù¢ÁπÅÁêêÁöÑËß£ÈáäÔºåÂè™ÊòØÊÉ≥Êó†ËÑëÁöÑÁõ¥Êé•ÂéªËß£ÂÜ≥ÈóÆÈ¢òÔºåÂèØ‰ª•Â∞ùËØïÁõ¥Êé•Â§çÂà∂‰ª•‰∏ãÂëΩ‰ª§Âú®‰Ω†È°πÁõÆÁöÑÊ†πÁõÆÂΩï‰∏ãÊâìÂºÄÁªàÁ´ØÂéªÊâßË°å„ÄÇ

     echo [ËøôÈáåÂÜô node ÁâàÊú¨Âè∑ÔºåÊ≥®ÊÑè‰∏çË¶ÅÊê∫Â∏¶‰∏ä‰∏≠Êã¨Âè∑] > .node-version

     ‰æã:   echo 20.11.1 > .node-version

     {}

Ëß£ÈáäÔºö
     Ê≠§Á±ªÈîôËØØÁöÑÁõ¥Êé•ÂéüÂõ†ÊòØ‰Ω†ÂΩìÂâçÊâßË°åÂëΩ‰ª§ÁöÑÁéØÂ¢ÉÊ≤°Êúâ‰∏Ä‰∏™ÂèØ‰ª•Ë¢´ÊâßË°åÁöÑ Node.
     Âú® snm ÁöÑÊâßË°åÈÄªËæë‰∏≠, ÈÄöÂ∏∏‰ºöÂÖàÊ£ÄÊü•‰Ω†ÊâßË°åÂëΩ‰ª§Êó∂ÊâÄÂú®ÁöÑÁõÆÂΩïÊòØÂê¶Â≠òÂú® .node-version Êñá‰ª∂‰∏îÊñá‰ª∂ÂÜÖÂÆπ‰∏∫‰∏Ä‰∏™ÊúâÊïàÁöÑ Node ÁâàÊú¨Âè∑,
     Â¶ÇÊûúÂ≠òÂú®Âàô‰ºö‰ΩøÁî®ËØ•ÁâàÊú¨ÁöÑ Node, Âê¶Âàô‰ºöÂ∞ùËØïÂú®ÂÖ®Â±ÄÂéªÂØªÊâæ‰∏Ä‰∏™ÈªòËÆ§ÁöÑ Node ÁâàÊú¨ÔºåÂ¶ÇÊûú‰πüÊ≤°ÊúâÊàêÂäüÁöÑÊâæÂà∞Âàô‰ºöÊäõÂá∫ËØ•ÈîôËØØ„ÄÇ

Ê≥®ÊÑè:
     ËØ∑Ê≥®ÊÑè Node ÁöÑÁâàÊú¨Âè∑ÈúÄË¶ÅÂÜôÂÆåÊï¥„ÄÇ ÈîôËØØÂÆû‰æã: 20, Ê≠£Á°ÆÂÆû‰æã: 20.11.1„ÄÇ
     ‰∏≠Êã¨Âè∑ÊåáÁöÑÊòØ  [ Êàñ ]
"##,
                if white_list.len() > 0 {
                    format!("ÁõÆÂâçÊîØÊåÅÁöÑ node ÁâàÊú¨Â¶Ç‰∏ã {}", white_list)
                } else {
                    "".to_string()
                }
            );
            eprintln!("{}", message);
        }
        SnmError::ExceededMaxRetries(url) => {
            let message = format!(
                r##"
ÈîôËØØ: Ë∂ÖËøáÊúÄÂ§ßÈáçËØïÊ¨°Êï∞

ÊñπÊ°à:
     ËØ∑Áõ¥Êé•ÈáçËØï‰Ω†ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøòÊòØÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•‰Ω†ÁöÑÁΩëÁªúËøûÊé•Âíå‰∏ãËΩΩÈìæÊé•ÊòØÂê¶Ê≠£Â∏∏„ÄÇÊàñÊ£ÄÊü•‰Ω†ÁöÑÁõ∏ÂÖ≥ÈÖçÁΩÆÊòØÂê¶Ê≠£Á°Æ„ÄÇ
     ÂæàÈöæÁªôÂá∫ÊòéÁ°ÆÁöÑÂª∫ËÆÆ„ÄÇ
     Áõ∏ÂÖ≥ÈÖçÁΩÆÊåáÁöÑÊòØ‰Ω†ÁöÑ Node ÁâàÊú¨‰ø°ÊÅØ‰ª•Âèä ÂåÖÁÆ°ÁêÜÂô®ÁöÑÈÖçÁΩÆ‰ø°ÊÅØ„ÄÇ
     Node ÁöÑÁâàÊú¨Âè∑Âú®‰Ω†È°πÁõÆÊ†πÁõÆÂΩïÁöÑ .node-version Êñá‰ª∂‰∏≠ÈÖçÁΩÆÔºåÈúÄË¶ÅÂÜôÂÆåÊï¥„ÄÇ ÈîôËØØÂÆû‰æã: 20, Ê≠£Á°ÆÂÆû‰æã: 20.11.1„ÄÇ
     ÂåÖÁÆ°ÁêÜÂô®ÈúÄË¶ÅÂú® package.json Êñá‰ª∂‰∏≠ÈÖçÁΩÆ packageManager Â≠óÊÆµÔºåÈÖçÁΩÆÊ†ºÂºè‰∏∫ [ÂåÖÁÆ°ÁêÜÂô®ÁöÑÂêçÁß∞]@[ÂåÖÁÆ°ÁêÜÂô®ÁöÑÁâàÊú¨Âè∑]Ôºå‰∏çË¶ÅÂ∏¶‰∏≠Êã¨Âè∑

Ëß£Èáä:
     snm Âú®Ëé∑Âèñ Node ‰∏é ÂåÖÁÆ°ÁêÜÂô®ÁöÑÊó∂ÂÄô‰ºöËøõË°å‰∏ãËΩΩÊìç‰ΩúÔºå‰∏ãËΩΩÁöÑÈìæÊé•ÊòØ {}

Ê≥®ÊÑè:
     ‰∏≠Êã¨Âè∑ÊåáÁöÑÊòØ  [ Êàñ ]
            "##,
                url
            );
            eprintln!("{}", message);
        }
        SnmError::ShasumError {
            file_path,
            expect,
            actual,
        } => {
            let message = format!(
                r##"
ÈîôËØØ: Ê£ÄÊü•shasumÈîôËØØ

ÊñπÊ°à:
     Âª∫ËÆÆ‰Ω†‰ºòÂÖàÂ∞ùËØïÈáçËØï‰Ω†ÁöÑÊìç‰ΩúÔºåÂ¶ÇÊûúËøòÊòØÂ§±Ë¥•ÔºåÂèØËÉΩ‰∏ãËΩΩÊñá‰ª∂ÂèóÂà∞ÊçüÂùèÊàñËÄÖË¢´ÁØ°Êîπ„ÄÇ

Ëß£Èáä:
     snm ‰ºöÈíàÂØπ‰∏ãËΩΩ‰∏ãÊù•ÁöÑ Node Êñá‰ª∂ËøõË°å shasum Ê†°È™åÔºå‰ª•Á°Æ‰øù‰∏ãËΩΩÁöÑÊñá‰ª∂Ê≤°ÊúâË¢´ÁØ°ÊîπÊàñËÄÖÊçüÂùè„ÄÇ
     ‰∏ãËΩΩ‰∏ãÊù•ÁöÑÊñá‰ª∂Ë∑ØÂæÑÊòØ {} , È¢ÑÊúüÁöÑ shasum ÂÄºÊòØ {} , ÂÆûÈôÖÁöÑ shasum ÂÄºÊòØ {}

Ê≥®ÊÑè:
     ËØ∑Ê≥®ÊÑè Node ÁöÑÁâàÊú¨Âè∑ÈúÄË¶ÅÂÜôÂÆåÊï¥„ÄÇ ÈîôËØØÂÆû‰æã: 20, Ê≠£Á°ÆÂÆû‰æã: 20.11.1„ÄÇ
     ÁõÆÂâçÁöÑÁâàÊú¨ÂåÖÁÆ°ÁêÜÂô®Ê≤°ÊúâËøõË°å shasum Ê†°È™åÔºåÂè™Êúâ Node ÁöÑÁâàÊú¨Êñá‰ª∂Êâç‰ºöËøõË°å shasum Ê†°È™å„ÄÇ

            "##,
                file_path, expect, actual
            );
            eprintln!("{}", message);
        }
        SnmError::UnsupportedNodeVersionError {
            version,
            node_white_list,
        } => {
            let v_str = node_white_list.join(", ");
            let message = format!(
                r##"
ÈîôËØØ: ‰Ω†ÈÖçÁΩÆÁöÑ Node ÁâàÊú¨‰∏çÂèóÊîØÊåÅ

ÊñπÊ°à:
    ‰Ω†ÈÖçÁΩÆÁöÑ Node ÁâàÊú¨ÊòØ {} , Êàë‰ª¨Âè™ÊîØÊåÅ {} ÂàóË°®‰∏≠ÁöÑÁâàÊú¨„ÄÇ

Ëß£Èáä:
    ÂΩìÂâçÁéØÂ¢ÉÈíàÂØπ Node ÈôêÂà∂‰∫ÜÁâàÊú¨Ôºå‰Ω†Âè™ËÉΩ‰ΩøÁî®Âú®Ë¢´ÂÖÅËÆ∏ËåÉÂõ¥ÂÜÖÁöÑ Node ÁâàÊú¨„ÄÇ

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè Node ÁöÑÁâàÊú¨Âè∑ÈúÄË¶ÅÂÜôÂÆåÊï¥„ÄÇ ÈîôËØØÂÆû‰æã: 20, Ê≠£Á°ÆÂÆû‰æã: 20.11.1„ÄÇ
    Êàë‰ª¨Âè™ÊîØÊåÅ {} ÂàóË°®‰∏≠ÁöÑÁâàÊú¨„ÄÇ
            "##,
                version,
                node_white_list.join(", "),
                v_str
            );
            eprintln!("{}", message);
        }
        SnmError::NotFoundPackageJsonFileError {} => {
            let message = format!(
                r##"
ÈîôËØØ: Ê≤°ÊúâÊâæÂà∞ package.json Êñá‰ª∂

ÊñπÊ°à:
    ËØ∑Ê£ÄÊü•ÂΩìÂâçÁõÆÂΩï‰∏ãÊòØÂê¶Â≠òÂú® package.json Êñá‰ª∂ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ËØ∑Êñ∞Âª∫‰∏Ä‰∏™ package.json Êñá‰ª∂„ÄÇ

Ëß£Èáä:
    ÈÄöÂ∏∏ÊÉÖÂÜµ‰∏ãÔºåËøôÁ±ªÈîôËØØÊòØÁî±‰∫é‰Ω†ÁöÑÈ°πÁõÆÊ†πÁõÆÂΩï‰∏ãÊ≤°Êúâ package.json Êñá‰ª∂ÂØºËá¥ÁöÑ„ÄÇ
    ËØ∑Ê£ÄÊü•ÂΩìÂâçÁõÆÂΩï‰∏ãÊòØÂê¶Â≠òÂú® package.json Êñá‰ª∂ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ËØ∑Êñ∞Âª∫‰∏Ä‰∏™ package.json Êñá‰ª∂„ÄÇ

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè package.json Êñá‰ª∂ÊòØ‰∏Ä‰∏™ÂøÖÈ°ªÁöÑÈÖçÁΩÆÊñá‰ª∂ÔºåÁî®‰∫éÊèèËø∞‰Ω†ÁöÑÈ°πÁõÆÁöÑÁõ∏ÂÖ≥‰ø°ÊÅØ„ÄÇ
    ËØ∑Ê≥®ÊÑè package.json Êñá‰ª∂ÁöÑ‰ΩçÁΩÆÔºåÂøÖÈ°ªÂú®È°πÁõÆÁöÑÊ†πÁõÆÂΩï‰∏ã„ÄÇ
    ËØ∑Ê≥®ÊÑè package.json Êñá‰ª∂ÁöÑÂÜÖÂÆπÔºåÂøÖÈ°ªÊòØ‰∏Ä‰∏™ÂêàÊ≥ïÁöÑ JSON Ê†ºÂºèÊñá‰ª∂„ÄÇ
"##,
            );
            eprintln!("{}", message);
        }
        SnmError::NotFondPackageManagerConfigError {} => {
            let message = format!(
                r##"
ÈîôËØØ: Ê≤°ÊúâÊâæÂà∞ packageManager ÈÖçÁΩÆ

ÊñπÊ°à:
    ËØ∑Ê£ÄÊü• package.json Êñá‰ª∂‰∏≠ÊòØÂê¶Â≠òÂú® packageManager Â≠óÊÆµÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ËØ∑Êñ∞Âª∫‰∏Ä‰∏™ packageManager Â≠óÊÆµ„ÄÇ

Ëß£Èáä:
    ÈÄöÂ∏∏ÊÉÖÂÜµ‰∏ãÔºåËøôÁ±ªÈîôËØØÊòØÁî±‰∫é‰Ω†ÁöÑ package.json Êñá‰ª∂‰∏≠Ê≤°ÊúâÈÖçÁΩÆ packageManager Â≠óÊÆµÂØºËá¥ÁöÑ„ÄÇ
    ËØ∑Ê£ÄÊü• package.json Êñá‰ª∂‰∏≠ÊòØÂê¶Â≠òÂú® packageManager Â≠óÊÆµÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ËØ∑Êñ∞Âª∫‰∏Ä‰∏™ packageManager Â≠óÊÆµ„ÄÇ

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÂøÖÈ°ªÊòØ npm„ÄÅyarn„ÄÅpnpm ‰∏âËÄÖ‰πã‰∏Ä
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÊ†ºÂºèÔºåÂøÖÈ°ªÁ¨¶Âêà [ÂåÖÁÆ°ÁêÜÂô®ÁöÑÂêçÁß∞]@[ÂåÖÁÆ°ÁêÜÂô®ÁöÑÁâàÊú¨Âè∑] ÁöÑÊ†ºÂºèÔºå‰∏çË¶ÅÂ∏¶‰∏≠Êã¨Âè∑
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÁâàÊú¨Âè∑ÂøÖÈ°ªÂÜôÂÖ®Ôºå‰∏çÊîØÊåÅÁÆÄÂÜôÁâàÊú¨Âè∑Ôºå‰æãÂ¶Ç: 9
    ‰∏≠Êã¨Âè∑ÊåáÁöÑÊòØ  [ Êàñ ]
"##,
            );
            eprintln!("{}", message);
        }
        SnmError::ParsePackageManagerError {
            raw_package_manager,
        } => {
            let message = format!(
                r##"
ÈîôËØØ: Ëß£Êûê packageManager ÈÖçÁΩÆÈîôËØØ

ÊñπÊ°à:
    Êü•ËØ¢Âà∞‰Ω†ÈÖçÁΩÆÁöÑ packageManager ÁöÑÂÄºÊòØ {} Èöæ‰ª•Ê†πÊçÆ‰∏ä‰∏ãÊñáÂáÜÁ°ÆÁöÑÊèê‰æõÂèØÂ∞ùËØïÁöÑ‰∏ÄÈîÆÂºè‰øÆÂ§çÊñπÊ°à

Ëß£Èáä:
    ÈÄöÂ∏∏ÊÉÖÂÜµ‰∏ãÔºåËøôÁ±ªÈîôËØØÊòØÁî±‰∫é package.json Êñá‰ª∂‰∏≠ÁöÑ packageManager Â≠óÊÆµÈÖçÁΩÆÈîôËØØÂØºËá¥ÁöÑ„ÄÇ
    ËØ∑Ê£ÄÊü• package.json Êñá‰ª∂‰∏≠ÁöÑ packageManager Â≠óÊÆµÊòØÂê¶Á¨¶Âêà‰ª•‰∏ãÊ†ºÂºè: [ÂåÖÁÆ°ÁêÜÂô®ÁöÑÂêçÁß∞]@[ÂåÖÁÆ°ÁêÜÂô®ÁöÑÁâàÊú¨Âè∑]Ôºå‰∏çË¶ÅÂ∏¶‰∏≠Êã¨Âè∑
    ‰æãÂ¶Ç: npm@9.0.0

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÊ†ºÂºèÔºåÂøÖÈ°ªÁ¨¶Âêà [ÂåÖÁÆ°ÁêÜÂô®ÁöÑÂêçÁß∞]@[ÂåÖÁÆ°ÁêÜÂô®ÁöÑÁâàÊú¨Âè∑] ÁöÑÊ†ºÂºèÔºå‰∏çË¶ÅÂ∏¶‰∏≠Êã¨Âè∑
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÂøÖÈ°ªÊòØ npm„ÄÅyarn„ÄÅpnpm ‰∏âËÄÖ‰πã‰∏Ä
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÁâàÊú¨Âè∑ÂøÖÈ°ªÂÜôÂÖ®Ôºå‰∏çÊîØÊåÅÁÆÄÂÜôÁâàÊú¨Âè∑Ôºå‰æãÂ¶Ç: 9
    ‰∏≠Êã¨Âè∑ÊåáÁöÑÊòØ  [ Êàñ ]
"##,
                raw_package_manager
            );
            eprintln!("{}", message);
        }
        SnmError::NotMatchPackageManagerError {
            raw_command,
            expect,
            actual,
        } => {
            let message = format!(
                r##"
ÈîôËØØ: ‰Ω†ÊâßË°åÁöÑÂëΩ‰ª§‰∏çÁ¨¶Âêà packageManager ÈÖçÁΩÆ

ÊñπÊ°à: 
    ËØ∑‰ΩøÁî®‰Ω†Âú® packageManager Â≠óÊÆµÈÖçÁΩÆÁöÑÂåÖÁÆ°ÁêÜÂô®ÊâßË°å‰Ω†ÁöÑÂëΩ‰ª§ 
    ‰Ω†ÈÖçÁΩÆÁöÑÂÜÖÂÆπÊòØ {} , È¢ÑÊúüÁöÑÂåÖÁÆ°ÁêÜÂô®ÊòØ {} , ÂÆûÈôÖÁöÑÂåÖÁÆ°ÁêÜÂô®ÊòØ {}


Ëß£Èáä:
    snm ‰ºöËØÜÂà´Âá∫‰Ω†ÁöÑ packageManager Â≠óÊÆµÈÖçÁΩÆÁöÑÂåÖÁÆ°ÁêÜÂô®ÔºåÁÑ∂ÂêéÂº∫Âà∂Á∫¶ÂÆöÂΩì‰Ω†‰ΩøÁî® install „ÄÅ i „ÄÅ run Ëøô‰∏â‰∏™
    ÂëΩ‰ª§ÁöÑÊó∂ÂÄô‰ºöËøõË°åÊ†°È™åÔºåÂ¶ÇÊûú‰Ω†ÊâßË°åÁöÑÂëΩ‰ª§‰∏çÁ¨¶Âêà packageManager ÈÖçÁΩÆÁöÑÂåÖÁÆ°ÁêÜÂô®ÔºåÈÇ£‰πàÂ∞±‰ºöÊäõÂá∫Ëøô‰∏™ÈîôËØØ„ÄÇ

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÂøÖÈ°ªÊòØ npm„ÄÅyarn„ÄÅpnpm ‰∏âËÄÖ‰πã‰∏Ä
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÁâàÊú¨Âè∑ÂøÖÈ°ªÂÜôÂÖ®Ôºå‰∏çÊîØÊåÅÁÆÄÂÜôÁâàÊú¨Âè∑ÔºåÈîôËØØÁ§∫‰æã: 9ÔºåÊ≠£Á°ÆÁ§∫‰æã: 9.0.0

            "##,
                raw_command, expect, actual
            );
            eprintln!("{}", message);
        }
        SnmError::UnsupportedPackageManagerError {
            raw,
            name,
            supported,
        } => {
            let message = format!(
                r##"
ÈîôËØØ: packageManager ÈÖçÁΩÆÁöÑÂåÖÁÆ°ÁêÜÂô®‰∏çÊîØÊåÅ

ÊñπÊ°à:
    Êü•ËØ¢Âà∞‰Ω†ÈÖçÁΩÆÁöÑ packageManager ÁöÑÂÄºÊòØ {} , {} ÂèØËÉΩÊòØ‰∏Ä‰∏™‰∏çÂèóÊîØÊåÅÁöÑÂåÖÁÆ°ÁêÜÂô®ÊàñËøôÊòØ‰∏Ä‰∏™‰∏çÂ≠òÂú®ÁöÑÂåÖÁÆ°ÁêÜÂô®„ÄÇ

Ëß£Èáä:
    ÂΩìÂâç snm ÈªòËÆ§Âè™ÊîØÊåÅ npm„ÄÅyarn„ÄÅpnpm ‰∏âÁßçÂåÖÁÆ°ÁêÜÂô®ÔºåÂ¶ÇÊûú‰Ω†ÁöÑÈÖçÁΩÆ‰∏çÊòØËøô‰∏âÁßçÂåÖÁÆ°ÁêÜÂô®‰πã‰∏ÄÔºåÈÇ£‰πàÂ∞±‰ºöÊäõÂá∫Ëøô‰∏™ÈîôËØØ„ÄÇ
    ‰Ω†ÈÖçÁΩÆÁöÑÂåÖÁÆ°ÁêÜÂô®ÊòØ {}

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè packageManager Â≠óÊÆµÁöÑÈÖçÁΩÆÂÜÖÂÆπÔºåÂøÖÈ°ªÊòØ npm„ÄÅyarn„ÄÅpnpm ‰∏âËÄÖ‰πã‰∏Ä
            "##,
                raw, name, name
            );
            eprintln!("{}", message);
        }

        SnmError::NotFoundCommandError { bin_name } => {
            let message = format!(
                r##"
ÈîôËØØ: Ê≤°ÊúâÊâæÂà∞ÂëΩ‰ª§ {}

ÊñπÊ°à:
    ËØ∑Ê£ÄÊü•‰Ω†ËæìÂÖ•ÁöÑÂëΩ‰ª§ÊòØÂê¶Ê≠£Á°ÆÔºåÂ¶ÇÊûúÊ≠£Á°ÆËØ∑Ê£ÄÊü•‰Ω†ÁöÑÁéØÂ¢ÉÂèòÈáèÊòØÂê¶ÈÖçÁΩÆÊ≠£Á°Æ„ÄÇ

Ëß£Èáä:
    ÂΩìÂâçÁéØÂ¢ÉÊ≤°ÊúâÊâæÂà∞‰Ω†ËæìÂÖ•ÁöÑÂëΩ‰ª§ÔºåËøôÂèØËÉΩÊòØÂõ†‰∏∫‰Ω†ËæìÂÖ•ÁöÑÂëΩ‰ª§‰∏çÊ≠£Á°ÆÊàñËÄÖ‰Ω†ÁöÑÁéØÂ¢ÉÂèòÈáèÊ≤°ÊúâÈÖçÁΩÆÊ≠£Á°Æ„ÄÇ

Ê≥®ÊÑè:
    ËØ∑Ê≥®ÊÑè‰Ω†ËæìÂÖ•ÁöÑÂëΩ‰ª§ÊòØÂê¶Ê≠£Á°ÆÔºåÂ¶ÇÊûúÊ≠£Á°ÆËØ∑Ê£ÄÊü•‰Ω†ÁöÑÁéØÂ¢ÉÂèòÈáèÊòØÂê¶ÈÖçÁΩÆÊ≠£Á°Æ„ÄÇ
            "##,
                bin_name
            );
            eprintln!("{}", message);
        }

        SnmError::SNMBinaryProxyFail { stderr: _ } => {
            let message = format!(
                r##"
ÈîôËØØ: snm ‰∫åËøõÂà∂‰ª£ÁêÜÂ§±Ë¥•

ÊñπÊ°à:
    ÈòÖËØªÈîôËØØÊó•ÂøóÔºåÊü•ÁúãÂÖ∂‰ªñÈîôËØØ

Ëß£Èáä:
    ÈÄöÂ∏∏ËøôÊòØÁî±ÂÖ∂‰ªñÈîôËØØÂºïËµ∑ÁöÑÔºåÂπ∂‰∏çÊòØÁõ¥Êé•ÊÄßÁöÑÈîôËØØÂéüÂõ†Ôºå‰Ω†ÂèØ‰ª•Êü•ÁúãÈîôËØØÊó•ÂøóÔºåÊü•ÁúãÂÖ∂‰ªñÈîôËØØ„ÄÇ

Ê≥®ÊÑè:
    Êó†
            "##,
            );
            eprintln!("{}", message);
        }

        SnmError::HttpStatusCodeUnOk
        | SnmError::GetWorkspaceError
        | SnmError::DeserializeError(_)
        | SnmError::NetworkError(_)
        | SnmError::DialoguerError(_)
        | SnmError::VarError(_)
        | SnmError::ZipError(_)
        | SnmError::BuildConfigError(_)
        | SnmError::IOError(_)
        | SnmError::GetHomeDirError
        | SnmError::FileAlreadyExists { file_path: _ } => {
            //             let msg = format!(
            //                 r##"
            // ÈîôËØØ:Ëøô‰∏çÊòØ‰∏Ä‰∏™È¢ÑÊúüÂÜÖÁöÑÈîôËØØ

            // ÊñπÊ°à:
            //     Êó†

            // Ëß£Èáä:
            //     Êó†

            // Ê≥®ÊÑè:
            //     Êó†
            //             "##,
            //             );
            eprintln!("error {}", error.to_string());
        }
    }
}

pub fn friendly_error_message(error: SnmError) {
    if let Ok(lang) = env::var("SNM_LANG") {
        if lang == "cn_zh" {
            hack(error);
            exit(1);
        }
    }

    match error {
        SnmError::SNMBinaryProxyFail { stderr: _ } => {
            // TODO ü§î how to show ?
        }
        SnmError::NoDefaultNodeBinary => {
            let message = create_error_message(
                format!("No executable default Node found"),
                vec![
                    fmtln!(
                        "Please use {} set default node",
                        "snm node default [node version]".bold().bright_green()
                    ),
                    fmtln!(
                        "Or use {}",
                        "echo [node version] > .node-version".bold().bright_green()
                    ),
                ],
            );
            eprintln!("{}", message);
        }
        SnmError::ParsePackageManagerError {
            raw_package_manager,
        } => {
            let message = create_error_message(
                "Parse package manager error".to_string(),
                vec![
                    format!(
                        "Please check the raw package manager configuration: {}",
                        raw_package_manager.bold().red()
                    ),
                    format!(
                        "Should satisfy {}, Example: {}",
                        "[packageManager]@[version]".bold().green(),
                        "npm@9.0.0".bold().green()
                    ),
                ],
            );
            eprintln!("{}", message);
        }
        SnmError::ExceededMaxRetries(url) => {
            let message = create_error_message(
                "Exceeded max retries".to_string(),
                vec![
                    fmtln!("URL {}", url.to_string().bold().red()),
                    fmtln!("The download failed after 3 retries.",),
                    fmtln!("Please check the network connection and the download URL",),
                ],
            );
            eprintln!("{}", message);
        }
        SnmError::GetHomeDirError => {
            eprintln!(
                r##"
        üëπ  Get home dir failed

            I think the possible reasons are:

            ¬∑ The HOME environment variable is not set.
            ¬∑ The HOME environment variable is not set correctly.
            ¬∑ The HOME environment variable is not set to a directory.

            Platform	    Value	                Example
            Linux	        $HOME	                /home/alice
            macOS	        $HOME	                /Users/Alice
            Windows	        FOLDERID_Profile	C:\Users\Alice

            Linux and macOS:
            Use $HOME if it is set and not empty.
            If $HOME is not set or empty, then the function getpwuid_r is used to determine the home directory of the current user.
            If getpwuid_r lacks an entry for the current user id or the home directory field is empty, then the function returns None.
            Windows:
            This function retrieves the user profile folder using SHGetKnownFolderPath.

            All the examples on this page mentioning $HOME use this behavior.

            Note: This function's behavior differs from std::env::home_dir, which works incorrectly on Linux, macOS and Windows.
            "##
            );
        }
        SnmError::FileAlreadyExists { file_path } => {
            let message = create_error_message(
                "File already exists".to_string(),
                vec![format!(
                    "The file {} already exists.",
                    file_path.to_string_lossy().bold().red()
                )],
            );
            eprintln!("{}", message);
        }
        SnmError::NotFoundCommandError { bin_name } => {
            let message = create_error_message(
                format!("Not found command {}", bin_name.bold().red()),
                vec![format!(
                    "The command {} is not found in the current environment.",
                    bin_name.bold().red()
                )],
            );
            eprintln!("{}", message);
        }
        SnmError::NotMatchPackageManagerError {
            raw_command,
            expect,
            actual,
        } => {
            let message = create_error_message(
                "Not match package manager".to_string(),
                vec![
                    format!("You input: {}", raw_command.bright_black()),
                    format!("Expect {}", expect.green()),
                    format!("Actual {}", actual.red()),
                ],
            );
            eprintln!("{}", message);
        }
        SnmError::ShasumError {
            file_path,
            expect,
            actual,
        } => {
            let message = create_error_message(
                "Check shasum error".to_string(),
                vec![
                    format!("File path {}", file_path.bright_black()),
                    format!("Expect {}", expect.bold().green()),
                    format!("Actual {}", actual.bold().red()),
                ],
            );
            eprintln!("{}", message);
        }
        SnmError::NotFoundPackageJsonFileError {} => {
            let message = create_error_message(
                "Not found package.json file".to_string(),
                vec![format!(
                    "Please check the current directory, whether the package.json file exists."
                )],
            );
            eprintln!("{}", message);
        }
        SnmError::NotFondPackageManagerConfigError {} => {
            let message = create_error_message(
                "Not found packageManager config".to_string(),
                vec![format!(
                    "Please check the package.json file, whether the packageManager field exists."
                )],
            );
            eprintln!("{}", message);
        }
        SnmError::UnsupportedNodeVersionError {
            version,
            node_white_list,
        } => {
            let list_message = node_white_list
                .iter()
                .map(|item| format!("- {}", item).to_string())
                .collect::<Vec<String>>();

            let message = create_error_message(
                format!("‰∏çÊîØÊåÅ {}", version.bold().bright_red()),
                vec![
                    vec![fmtln!("{}", "Âè™ÊîØÊåÅ‰ª•‰∏ãÂàóË°®:")],
                    list_message,
                    vec!["\r\n".to_string()],
                    vec![
                        "ü§î Â¶Ç‰ΩïËÆæÁΩÆÂΩìÂâçÈ°πÁõÆÁöÑ node ÁâàÊú¨".to_string(),
                        "ËØ∑ÂÖàÊ£ÄÊü•È°πÁõÆÊ†πÁõÆÂΩïÊòØÂê¶Â≠òÂú® .node-version Êñá‰ª∂".to_string(),
                        "Â¶ÇÊûú‰∏çÂ≠òÂú®ÔºåËØ∑Êñ∞Âª∫ .node-version Êñá‰ª∂".to_string(),
                        "Âú® .node-version Êñá‰ª∂‰∏≠ÂÜôÂÖ•‰Ω†ÁöÑ node ÁâàÊú¨".to_string(),
                        "ËØ∑Ê≥®ÊÑè‰∏çÊîØÊåÅÁÆÄÂÜôÁâàÊú¨Âè∑Ôºå‰æã: 14 „ÄÇÂä°ÂøÖ‰øùËØÅÁâàÊú¨Âè∑ÂÜôÂÖ®".to_string(),
                        "Âä°ÂøÖ‰øùËØÅÁâàÊú¨Âè∑ÂÜôÂÖ®Ôºå‰æã: 14.17.0„ÄÇ".to_string(),
                        "ËØ∑Ê≥®ÊÑè‰ª•‰∏äÊèêÁ§∫ÁßçÊâÄËØ¥ÁöÑ 14 ‰ª•Âèä 14.17.0 ‰ªÖ‰ªÖÂè™ÊòØ‰∏æ‰æã".to_string(),
                        "‰Ω†ÈúÄË¶Å‰øùËØÅ‰Ω†ÂÜôÁöÑÁâàÊú¨Âè∑Âú®ÊîØÊåÅÁöÑÂàóË°®ÂÜÖ„ÄÇ".to_string(),
                    ],
                ]
                .concat(),
            );
            eprintln!("{}", message);
        }
        SnmError::UnsupportedPackageManagerError {
            raw,
            name,
            supported,
        } => {
            let message = create_error_message(
                format!("Unsupported packageManager {}", name.bold().bright_red()),
                vec![
                    vec![
                        fmtln!("The raw package manager configuration is {}, Only the following list is supported:", raw.bold().bright_red()),
                    ],
                    supported
                        .iter()
                        .map(|item| format!("- {}", item).to_string())
                        .collect::<Vec<String>>(),
                ]
                .concat(),
            );
            eprintln!("{}", message);
        }

        SnmError::HttpStatusCodeUnOk
        | SnmError::GetWorkspaceError
        | SnmError::DeserializeError(_)
        | SnmError::NetworkError(_)
        | SnmError::DialoguerError(_)
        | SnmError::VarError(_)
        | SnmError::ZipError(_)
        | SnmError::BuildConfigError(_)
        | SnmError::IOError(_) => {
            let msg = format!("{}", error.to_string());
            // panic!("{msg}");
            eprintln!("[error]: {}", msg);
        }
    }

    exit(1);
}
